## 이더리움 토막상식(2-1)

1. 비콘체인 balancing attack  
지분증명 블록체인을 공격하는 방식은 여러 형태가 있다. 비트코인 같은 작업증명의 경우 이론적으로 해시파워 51%를 가지면 네트워크를 장악할 수 있다고 말하는 것처럼 지분증명도 대략 66% 이상의 지분을 확보하면 된다. 현재(2023년 9월) 약 2600만 이더가 참여하고 있고 66%는 270억 달러 정도의 이더를 확보해야 한다는 계산이 나오는데 현실적이지는 않다. 또는 33% 이상을 확보하면 데이터의 합의를 방해할 수도 있다.  

   큰 지분을 확보하지 않더라도 확률적으로 가능한 공격 방식이 있는데 그 중에 하나가 "balancing attack" 이다. 이 방법은 억지스러운 면이 있어서 크게 신경쓰지 않아도 된다고 생각하는 사람들이 있는 반면 현실적으로 가능하다고 보는 쪽도 있다. 이더리움 재단의 입장은 후자에 속한다. 아래 블로그를 참조.  
   [Finalized no. 31](https://blog.ethereum.org/2021/11/02/finalized-no-31)  
이 공격은 의도적으로 분기 상황을 짧은 시간 동안 유지하게 만들어서 블록체인이 reorg 상황에 처하도록 만드는 공격 방식이다(short-range reorg). 프로토콜 위반도 아니고 또 이를 시도하는 공격자가 얻는 이익이 명확하지 않지만 분기가 지속된다는 것은 대다수가 합의하는 단일한 마스터 원장을 추구하는 블록체인에서는 바람직하지 않다.  

   우선 공격자는 연속적으로 인접한 슬롯에서 블록 생성자로 선택되어야 한다. 블록 생성자는 슈도랜덤이지만 단일 주체가 운영하는 검증노드가 연속적인 슬롯에 배치되는 것이 불가능하지는 않다. 또 1 epoch 전에 검증자들이 슬롯에 스케줄링되므로 블록 생성자들을 미리 알 수 있다.  
다음은 각 슬롯에 공격자가 컨트롤 가능한 검증자들이 어느정도 분포되어 있어서 attestation을 제어할 수 있어야 한다. "balancing attack"이라는 이름에서 유추해볼 수 있는 것처럼 
연속으로 배치된 슬롯에서 분기를 형성한 다음 이후 분기 블록에 대해 다른 정상 검증자들의 attestation 상황을 보면서 각 분기 블록의 attestation을 balancing하여 "tie"를 이루도록 하는 것이다(어려운 용어로 "Ex post reorg"라고 한다). 공격자는 자신이 제어 가능한 attestation 메시지들을 적당한 시간에 전파해서 정상 검증자들 중 대략 50%에게 LMD-GHOST 투표에 영향을 줄 수 있다.  
자세한 내용은 아래 문서를 참조할 것.  
[Three Attacks on Proof-of-Stake Ethereum](https://arxiv.org/abs/2110.10086)


2. Proposer boost  
앞서 balancing attack은 LMD-GHOST가 검증자들의 최근 attestation만을 고려하는 특성을 이용한 것으로 검증 노드의 일정한 비율을 확보한 공격자가 자신의 attestation을 re-balancing하여 tie 상태를 의도적으로 지속하는 것이었다.  
비콘 노드 클라이언트 개발팀들은 이러한 공격에 대응하기 위해 "Proposer boost"라는 기능을 추가했다. 단지 최근 메시지만을 고려하는 것이 아니라 블록 생성자 즉 Proposer가 제 시간에 블록을 생성한 경우 아직 그 블록에 대한 attestation이 확보되기 전에 "boost"해서 최근 블록으로 판단한다는 것이다. 이렇게 하면 설령 공격자가 상황에 따라 자신들의 attestation을 제어하더라도 정상적인 블록 생성자의 블록으로 canonical 체인을 형성할 수 있다.  


3. 비콘체인의 7-block reorg "사건(incident)"  
2022년 5월 22일 비콘체인에서 연속 7개 슬롯에서 생성된 블록이 전부 reorg 되는 사건이 발생했다. 이것을 "사건"으로 규정한 것은 "hacking"이나 보안취약점으로 인한 "exploit"이 아니기 때문이다.  
프리즘 개발자인 테렌스의 트윗을 인용해보자.  
[7-block reorg](https://twitter.com/terencechain/status/1529566839033933824)  
Proposer boost는 비콘체인 클라이언트의 추가 기능이었기 때문에 클라이언트를 개발하는 여러 팀들은 수정된 버전의 배포 시점이 모두 상이했다. 당시 클라이언트 사용 비율이 높았던 프리즘이 가장 먼저 Proposer boost 버전을 배포했다.  
프리즘 외에 다른 클라이언트를 사용하는 검증 노드들은 여전히 LMD-GHOST를 기준으로 최근 블록을 판단했기 때문에 블록을 바라보는 view가 달랐고 이로 인해 "boost"된 7개의 블록들이 진행되다가 결국 8번째는 LMD인 블록을 최근 블록으로 판단하면서 이전에 만들어진 7개의 블록들이 reorg되고 말았다.  
이 사건은 긍정적으로 보자면 이더리움이 프로토콜 대로 동작하고 있다는 것을 증명한 것이지만, 반대로 보면 개별적으로 구현된 클라이언트들의 버그나 불일치로 인해 장시간 reorg가 발생할 수 있음을 보여주었다.  


4. 지분증명 전환 후 geth만으로 동기화 가능?  
현재는 불가능하다. geth와 같은 실행계층 클라이언트는 더이상 블록을 가십(gossiping)하지 않으므로 체인 자체가 형성되지 않는다. 다만 트랜잭션들은 이전처럼 전파되고 공유된다. 논리적으로는 비콘체인의 블록에 실행블록이 payload 형태로 포함되어 있는 구조이다.  


5. 유효잔액(Effective Balance)  
유효잔액은 프로토콜에서 필요한 여러 값을 계산하는데 사용되는 상수에 해당한다. 일반적인 잔액은 보상이 쌓이면서 계속 변하는데(물론 32Ξ 이상이면 인출이 되지만 인출 설정을 하지 않은 계정도 있을 수 있다) 많은 잔액을 보유한 검증자들에게 쏠림 현상이 나타나지 않도록 일종의 평등한 기회를 주기 위한 성격이 있다.
검증자의 유효잔액은 최대 32개를 넘을 수 없고(MAX_EFFECTIVE_BALANCE=32) 소수점이 나올 수 없다. 현재 잔액이 +1.25Ξ 늘어나면 유효잔액은 +1 늘어난다. 현재 잔액이 -0.25Ξ 감소하면 유효잔액은 -1 감소한다.  
앞서 말한 것처럼 유효잔액은 해당 검증자의 보상을 계산할 때 사용되고 또 블록 생성자를 선택할 때 활용된다. 또 66% 이상의 합의는 전체 유효잔액의 66%를 의미하기 때문에 검증자의 유효잔액이 낮으면 그에 비례하여 attestation weight도 작아진다고 말할 수 있다. 만약 검증노드를 오랜 시간동안 운영하지 않아 유효잔액이 16Ξ까지 떨어지면 검증자 풀에서 자동으로 제외된다. 


6. 블록 생성자 선택 확률  
모든 노드들이 동일한 검증자를 해당 슬롯에서 블록 생성자로 계산해야 하므로 슈도랜덤하게 선택한다. 비콘체인은 현재 RANDAO라는 방식으로 난수를 계산하여 블록 생성자 번호를 선택한다. 지분증명 전환 후에 RANDAO 값은 실행블록의 `mixHash` 항목에 기록되고 있다.  
그런데 블록 생성자 선택 확률은 유효잔액의 영향을 받는다.  
   ```
   if effective_balance * MAX_RANDOM_BYTE >= MAX_EFFECTIVE_BALANCE * random_byte:
      return candidate_index
   ```
   위와 같은 로직이 적용되어 있기 때문에 슈도랜덤이라고 해도 검증자의 유효잔액 `effective_balance`이 작으면 선택될 확률이 상대적으로 줄어든다. 결과적으로 정상적으로 성실하게 검증 노드를 운영하면 유효잔액은 항상 32를 유지하게 될 것이고 그렇게 되면 슈도랜덤하게 선택되기만 기대하면 된다.  


7. 최대 유효잔액을 늘리자는 제안(EIP-7251)  
현재 32로 고정된 최대 유효잔액(MAX_EFFECTIVE_BALANCE)을 늘려야 한다는 제안. 이유는 검증자 수가 계속 증가 추세에 있고 이것은 합의계층에서 주고 받는 메시지가 늘어나서 네트워크와 처리용량의 부하가 커질 가능성이 많기 때문이다. 과거 실행계층의 상태 트리가 커지는 것이 문제였던 것처럼 검증자가 늘어나서 attestation의 수가 많아지면 처리할 데이터들도 그만큼 늘어나게 되는 것은 당연하다.  
최대 유효잔액이 32로 고정되어 있으므로 검증 보상을 늘리기 위해서는 Lido 같은 스테이킹 풀이 수많은 검증노드를 계속 추가해서 운영할 수 밖에는 없다. 유효잔액을 늘리면 32개씩 나눌 필요가 없으므로 노드 수는 줄어들게 된다. 하지만 검증자가 되기 위한 최소 예치 수량은 여전히 32개로 변하지 않는다. EIP-7251은 유효잔액을 2048Ξ까지 늘리는 것을 제안한 상태이다. 보다 자세한 사항은 아래 링크 참조.  
[EIP-7251 FAQ](https://notes.ethereum.org/@mikeneuder/eip-7251-faq)  


8. 이더리움 성능개선 - 샤딩(Sharding)  
이더리움이 지분증명으로 전환하면서 초기에는 크게 세 단계(Phase)의 로드맵을 제시했다. Phase 0은 비콘체인, Phase 1은 샤딩, Phase 2에서는 실행계층(eWASM). 지금은 이것을 기억하는 사람이 거의 없을 것 같은데 왜냐하면 Phase 0 단계가 진행되는 중에 로드맵이 많이 수정되었기 때문이다.  
2020년 10월 비탈릭 부테린이 제시한 소위 "[롤업 중심의 로드맵](https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698)"이 가시화되면서 많은 부분에서 변화가 시작되었다.  
이더리움은 고성능 단일 L1 체인의 길을 버리고 흔히 말하는 다계층 또는 모듈식(modular) 블록체인을 지향하고 있다. 그런 맥락에서 이더리움 샤딩 초기에는 수십 또는 수천 개의 샤드를 나누고 각 샤드별로 (병렬적으로) 트랜잭션들을 처리하는 방향으로 가는 듯 했으나 복잡하고 해결하기 어려운 문제가 많아서 결국 "롤업" 중심으로 방향을 돌리게 된다.  
현재 이더리움의 샤딩은 "Danksharding"이라고 부르며 L2의 롤업 데이터를 어떻게 나누어서 저장하고 검증할 것인가에 대한 문제에 집중하고 있다. 즉 이더리움의 샤딩은 이더리움 L1을 "Data Availability(또는 Data Publishing)" 계층으로 사용하는 데이터 샤딩이고, 사람들이 생각하는 성능개선 즉 저렴하고 빠른 트랜잭션 처리는 사실상 다양한 L2 개발팀들이 해결해야 할 과제로 넘겨버린다. Danksharding은 그것을 제안한 [Dankrad Feist](https://twitter.com/dankrad)의 이름에서 유래한다.  
샤딩된 데이터의 저장공간을 트랜잭션이 저장되는 블록과 구별하여 "Blob space" 라고 한다. blob은 일반적으로 바이너리 데이터를 통칭하는 용어이다. L2에서 발생한 많은 거래 데이터를 압축해서 전송하기 때문에 blob이라고 표현하는 것 같다.


9. proto-danksharding  
완전한 샤딩에 해당하는 Danksharding으로 가는 것은 시간이 많이 걸리는 일이기 때문에 처음에는 일부만을 구현하는 계획을 세우게 된다. 그 첫 단계가 "proto-danksharding"이다. "proto"는 옵티미즘에서 일하는 개발자 [proto.eth](https://twitter.com/protolambda)의 제안에서 유래한다. 2023년 하반기에 예정되어 있는 Deneb+Cancun 하드포크의 EIP-4844로 적용될 예정이다.  
proto-danksharding은 엄밀히 말하면 샤딩이 없는 샤딩이다. 즉 샤딩의 주요 목적 "분할해서" 롤업 데이터를 검증하는 DAS(Data Availability Sampling)는 구현하지 않는다. 완전한 샤딩을 위해 기본 기능들을 구현하거나 나중에 더 개선된 것으로 대체하기 위한 준비 단계의 성격이 크다.  
지금 L2의 롤업 데이터들은 실행블록의 calldata 형태로 저장된다. 다시 말해서 일반적인 트랜잭션과 동일하고 그래서 가스비의 부담이 크다(트랜잭션이 몰리는 경우에는 L1의 수수료보다 비싼 적도 있었다). L2의 수수료의 많은 부분이 L1에 데이터를 저장하기 위한 트랜잭션 비용이기 때문에 이를 더 낮추면 L2의 성능개선이 획기적으로 이루어질 수 있다. 그래서 "blob 트랜잭션"이라는 롤업 데이터 전용 트랜잭션을 별도로 만들고 "데이터 가스"를 적용하여 다른 수수료 체계를 따르도록 한다. 물론 현재 트랜잭션 가스비보다는 훨씬 저렴할 것으로 예상된다.  

   ![2_1.png](img/fig2_1.png)

10. 

